#ifndef EVKUZ_H
#define EVKUZ_H

/*
 *
 *
 *  ~/iqr_lit/mobman/gui-client/release/cv-checker.log
 *  "GET /favicon.ico HTTP/1.1"
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++
 * 07.07.2022
 * Команда "RESET" очень актуальна, надо добавить.
 *
 * //+++++++++++++++++++++++++++++++++++++++
 * 24.06.2022
 * Добавил сигнал  &myThread::finished.
 * ДОбавил кнопку "STOP Polling"
 * Теперь по нажатию кнопки поток ставится на паузу и запрос статуса не отправляется.
 * При нажатии на кнопку "STATUS 2t./SEC" запрос статуса в потоке возобновляется.
 * Удалось "вырубить" hiwonder-web. Теперь задача, чтоб сам hiwonder-web ловил вот это событие и не вываливался, а писал в лог, что происходит.
 * И здесь, на стороне клиента, после отвала hiwonder-web (server) сообщения в лог :
 *
 *
 * 0x2222: The connection was refused by the peer. Make sure the server HIWONDER is running,
 * and check that the host name and port settings are correct.
 *
 * 0x9999: SocketDev state changed Current socketDev state is 1
 * 0x9999: SocketDev state changed Current socketDev state is 2
 * 0x9999: SocketDev state changed Current socketDev state is 0
 *
 * Смотрим https://doc.qt.io/qt-6/qabstractsocket.html#SocketState-enum
 *
 * Т.е. хронологически состояние сокета меняется так :
 * - QAbstractSocket::HostLookupState
 * - The socket has started establishing a connection.
 * - The socket is not connected.
 *
 * Т.е. хост находит, но там никто не слушает порт 8383, тогда сокет не подключен.
 *
 * //++++++++++++++++++++++++++++++++++++
 * Для имитации запросов от ЦУП добавляем таймер опроса статусов.
 * А для таймера нужен отдельный поток.
 * Пока таймер неиспользуем. Просто паузим поток.
 *
 * //++++++++++++++++++++++++++++++++++++
 * Если целевой хост не отвечает, например не запущен hiwonder-web, то надо что-то сообщать в лог, а то пока тишина в таком случае.
 * Сделано. Ф-ция MainWindow::socketErrorToLog_Slot(QString message)
 * Выдает сообщение самой системы Qt :
 * "2022-06-24__13:01:21:996 > 0x2222: The following error occurred:
 * Out of resources
 * "
 *
 * //++++++++++++++++++++++++++++++++++++++++
 * 01.06.2022
 * Доделал вчерашнюю задачу с поллингом.
 * Изменена схема работы потока.
 *
 * При запуске программы создается объект класса "clientSocket", инициализируются значения ip, port
 *
 * По нажатию кнопки стартует поток.
 * В потоке запускается eventloop в виде while-цикла.
 * Внтури поток тормозится на 200мс и далее отправляется сигнал myThread::SendToTcp_Signal().
 * НА этот сигнал срабатывает слот &clientSocket::SendToTcp_Slot, внутри слота :
 * - Создается объект QTcpSocket
 * - Задаются слоты для сигналов : &QIODevice::readyRead, &QTcpSocket::connected,
 * - Подключение к хосту, которое обработается уже слотом &clientSocket::onDEVSocketConnected_Slot (сигнал &QTcpSocket::connected),
 * в котором данные отправляются на сервер.
 *
 * По приходу ответа от сервера срабатывает сигнал &QIODevice::readyRead (родитель для QAbstractSocket), который обрабатывается слотом
 * &clientSocket::onReadyRead.
 *
 * При завершении соединения, по сигналу &QAbstractSocket::disconnected, который приходит от сервера, т.е. он закрывает соединение, происходит
 * закрытие объекта QTcpSocket (создан в слоте &clientSocket::SendToTcp_Slot).
 *
 * ОСтался вопрос по выключению потоков.
 * Пока расчет на то, что они удаляются вместе с закрытием программы.
 * В деструкторе MainWindow::~MainWindow() стоят соответствющие delete-ы
 *
 * - При вызове connectToHost() может быть выключен сервер, надо это отлавливать, и в лог сообщать.
 * - Реальную ошибку QAbstractSocket::SocketError  не выдает.
 * Пишет "0x2222: Just Initialize". Т.е. сигнал срабатывает, а данных нет...
 *
 * //++++++++++++++++++++++++++++++++++++
 * 31.05.2022
 * Задача :
 * - Добавляем кнопку "STATUS 2t./sec". По нажатию запускается поток, в котором 2 раза в секунду отправляется запрос статуса.
 *
 * Переделаем схему работы.
 * Поток только отсчитыает 500мс и дает сигнал "ОТправляй !"
 * Объект clientSocket ловит этот сигнал и далее :
 * - создает сокет
 * - подключается к хосту
 * - отправляет запрос
 * - По сигналу onReadyread считывает ответ.
 *
 * //++++++++++++++++++++++++++++++++++++
 * 23.05.2022
 * Т.к. проект постепенно становится универсальным для разных роботов, то следует добавить LinEdit-ы для ip и port, и переделать код,
 * чтобы запросы отправлялись по указанным ip:port
 *
 * //++++++++++++++++++++++++++++++++++++
 * 16.03.2022
 * - Добавляем кнопку "Move_To_Take_Cube" для Ручника.
 * - Добавляем кнопку "Start" для HiWonder
 * - Добавляем кнопку "Get ON Distance" - взять с заданной дистанции, дистанцию прописываем в мм в окне.
 *
 * //++++++++++++++++++++++++++++++++++++
 * 06.02.022
 * Добавляем кнопки для команд в новом формате
 * //++++++++++++++++++++++++++++++++++++
 * 10.01.2022 start
 *
 * Ветка mobman-json (mobman_02)
 * Создаем GUI-клиент для тестирования http-обмена с манипулятором и с CV.
 * Вручную команды вводить уже надоело.
 *
 *
 * //++++++++++++++
 * 25-26.01.2022
 * - Делаем поиск по ключу "detected" - находится во вложенном объекте "data" : {}
 * - Получаем все пары ключ : значение, включая вложенные объекты.
 * - Добавил проверку на тип Array для элемента JSON-объекта.
 *
 * Можно добавлять полученный функционал в demo01. Т.е. в итоге используем встроенные классы Qt для работы с JSON
 *
    #include <QJsonDocument>
    #include <QJsonParseError>
    #include <QJsonObject>
    #include <QJsonValue>
    #include <QJsonArray>
 * Задача :
 * - Отправлять ответ от mobman на команду "get_box". Т.е. команду "get_box" теперь следует  посылать в виде [Поставлено в очередь.]
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 24.01.2022
 * Получаем ответ от камеры в виде JSON-строки.
 * Задача - работать с этими данными именно как с json-данными. Пока только как строки.
 * Есть пример https://forum.qt.io/topic/94898/get-json-value-from-api-response/5
 *
 * - Научился ловить все значения из json. Есть проблема с первым ключом во вложенном объекте, но это решим. [Решено. НАдо сначало к типу bool приводить, а потом boolvalue.toString]
 * Фиксируем.
 * - Научился ловить значение distance из весго ответа, можно пользоваться.
 *   НО... пока это работает т.к. заранее известны поля и их типы значений. НА универсальность претендовать не может.
 *   Т.е. парсинг запускается, но мы заранее ожидаем, что там есть вложенный объект (делаем проверку однако), а в этом объекте должен быть ключ "distance"(тут уже без проверок).
 *   Т.е. "по уму" надо удостовериться, что в списке ключей есть нужный нам, в данном случае - "distance".  Это задача на будущее, а пока фиксим.
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 20.01.2022
 * Добавил рекурсивный парсинг json, если есть вложенные json-объекты.
 * Используются QT-классы
 * - <QJsonDocument>
 * - <QJsonParseError>
 * - <QJsonObject>
 * - <QJsonValue>
 * - <QJsonArray>
 * Ф-ция traversJson(QJsonObject json_obj)
 * Будем добавлять либу https://github.com/nlohmann/json
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 18.01.2022
 * В протоколе взаимодействия прописано, что в ответ на action, устройство среди прочего в ответ посылает поле name- имя девайса. Так что
 * можно спокойно делать в одной ф-ции работу с tcpsocket.
 *
 * Задачи :
 * - qtcpsocket - решить проблему с чтением данных.[сделано]
 * - парсинг JSON ответа от CV, вывод значений полей в лог
 * - ответ на команды "get_box", "ready" и т.д. в формате json.
 *
 * С чтением данных проблема решена. Не надо на стороне клиента (здесь) закрывать соединение. Надо ждать, когда сигнал "disconnect" от сервера (отправитель) придет.
 * Т.е. я убрал socketDEV->disconnectFromHost();
 * Те, что остались в других ф-циях - для обратной совместимости. Эти ф-ции не используются, потом уберу их.
 * В таком случае осталась задача убрать из ответа устройства HTTP-заголовки. [Сделано частично - начало JSON-данных ищется по символу '{', все предыдущие данные отбрасываются]
 * В этой связи еще надо посмотреть класс QNetworkAccessManager, т.к. заявлено, что :
 * "One QNetworkAccessManager instance should be enough for the whole Qt application. Since QNetworkAccessManager is based on QObject, it can only be used from the thread it belongs to."
 * Пока тестирую JSON-парсинг на const строке. - СДелано. Получаю значения key - value

 *
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 17.01.2022
 * При увеличении числа команд, отправляемых по нажатию кнопки (на каждую команду своя кнопка) происходят однотипные действия :
 * - 1. Создать сокет (для камеры CV или для манипулятора - разные девайсы)
 * - 2. Соединиться с хостом
 * - 3. После успешного соединения отправить запрос в сокет
 * - 4. Считать данные (ответ) из сокета при появлении оных там.
 *
 * В этой связи нет смысла на каждую кнопку создавать свой отдельный сокет с одинаковым кодом.
 * У нас меняется только запрос. А ответ мы принимаем одинаково и направляем его в парсер ответов.
 * Тогда получаем следующую последовательность :
 * - Значит запрос формируем на шаге 1 - в слоте нажатия кнопки и храним в глобальной переменной (создаем строку, у нас же запрос - это GET запрос, т.е. строка),
 * и далее - шаг 2 - вызываем ф-цию создания сокета.
 * - Отправляем сформированную строку в сокет на шаге 3. Т.е. на этом шаге берем уже ранее сформированную строку из глобальной переменной.
 * - Ответ направляем в парсер. И вот парсеру придется совсем туго... Как он определить из какого устройства пришел ответ ???
 * Изменения предстоят структурные, т.е. фундаментальные и масштабные :)
 * Поэтому сначала фикс текущего состояния.
 *
 * Создал вышеозначенный функционал. В целом работает.
 * Надо написать отдельный слот из строчки
 * connect(socketDEV, SIGNAL(disconnected()), this, SLOT(CV_onDisconnected()),Qt::AutoConnection); [сделано, ф-ция socketDEV_onDisconnected_Slot()]
 *
 * - Теперь еще надо добавить ответ от манипулятора на запросы "ready", "parking", так, чтобы в логе было понятно т.е. что-то типа "parking DONE"
 * - Продумать как анализировать ответ от устройств. Когда каждый сокет создается как отдельный объект - понятно. А когда сокет один на двоих - непонятно.
 * - В общем, надо вспомнить, что там в описании протокола.
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 11.01.2022
 * Промучился с QDataStream - не работает.
 *
 * Будем искать дальше варианты
 *
 * ОТкрываем сокет для манипулятора и отдельный сокет для CV. Код там почти повторяется...
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
#endif // EVKUZ_H

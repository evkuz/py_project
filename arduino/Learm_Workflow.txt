Робот Learm настройка, управление.
Смотрим на досуге

https://ph0en1x.net/108-avr-c-source-modules-compilation-makefile-howto-linux.html


Коды команд.

{servo1, servo2, servo3, servo4, servo5, servo6, direction, comand_type}

Параметр    значение

servo1/6        0-180
directiion      0x30, 0x31 - движение туда, движение обратно
command_order   0xC8 == 200 обычная команда
                0xDE == 222 Последняя команда роботу при комплексном движении
                0xE9 == 233 Предпоследняя команда - положить кубик на тележку.
                0xF4 == 244 Кубик на тележку положили, теперь грамотно убираем манипулятор.
                
                
                
                
//+++++++++++++++++++++++++++++++++++    
21.10.2021
Пояснения по движению приводов.
Ранее предполагалось, что манипулятор начинает свое движение из позиции "start", т.е. все приводы установлены на 90грд.
Исходя из этого было понятно, что максимальная дельта привода не может быть больше 90грд., т.к. приводы работают в диапазоне 0 -180.
Поэтому в программе переменная maxdt=100 - когда все приводы встали в нужную позицию.

Пока остается задачей движение приводов по убыванию номера, например, с 6 по 4. Думаем над этим.
НАпример создаем массив, где номер привода берется не по индексу, а по значению элемента массива.
В таком случае, перебирая индексы по возрастанию, мы перебираем сервы в любом заданном порядке, главное правильно присвоить значения
элементам массива.

            
//+++++++++++++++++++++++++++++++++++
30.09.2021
Есть особенность при постановке кубика на тележку.
Т.к. платформа выше пола, то углиы приводов 3,4 заметно отличаются от обычных в этой точке на полу.
И получается, что привод 3, срабатывая последним двигается незначительно, примерно на 5 градусов.
Это выглядит как отдельное движение.
ПРи взятии кубика выглядит нормально, а при постановке - не очень.

Как вариант, вижу ввести дополнительный код - "Предпоследняя команда" (открытие захвата не считаем)
И если такая команда, то приводы двигаются в другом порядке.

Т.е. крайний, 8 байт расширяет спектр своих значений.


//++++++++++++++++++++++++++++++
Взято из кода для ПК (отыскал через git)
 21.09.2021
  Вводим дополнительный байт(уже 8-й), - индикатор "Последняя команда" ДА/НЕТ.
  Процессор, увидев что это последняя команда, вместо обычного
  "Robot movement DONE! Total!!" ответит :
  "Robot movement DONE! LAST !!"
  По строке "LAST" ПК поймет, что это была последняя команда и
  тогда можно будет посылать сообщение web-серверу.
 

//+++++++++++++++++++++++++++=
17.09.2021
* Зафиксировал размеры посылок в коде arduino :
* - "Туда", т.е. от ПК к роботу - это 7 байт
* - "Обратно", т.е от робота к ПК - это 32 байта.

//++++++++++++++
16.09.2021

https://forum.arduino.cc/t/serial-input-basics-updated/382007/3

Занимаемся размером tx-буфера у ком-порта arduino nano, ибо мы на границе корректной работы.
Если понадобится пересылать от робота большее количество байт, мы получим проблемы с логами от робота.
Касаемо serial.flush()

It is probably worth mentioning that the poorly named Serial.flush() function does not empty the input buffer.
It is only relevant when the Arduino is sending data and its purpose is to block the Arduino until all outgoing the data has been sent.

Надо сделать фиксированное количество байт в посылках туда и обратно.
//++++++++++++++++++++
15.09.2021
НЕпонятно почему, но размер буфера TX у ардуино нано 32 байта
Как ни менял - не помогает !!
//++++++++++++++++++++++++++++++++++++++
25.06.2021

Теперь движения робота разделены на этапы:
- 6-4 приводы
- 1 привод
- 3- привод

Это хорошо работает, когда робот идет за кубиком, - "туда", а вот когда идет обратно (не захватывая кубик), то 
первым начинает сдвигаться опять 6 привод и часто задевает кубик, чем сдвигает его, т.к. зхвать остается на той же высоте.
Выход - разделить движения на "туда" и "обратно", вводим 7-й байт (байт флагов).
Пусть первый бит отвечает за направление. 1 - "туда", 0 - "обратно".
Соответственно, когда привод движется обратно, то все приводы срабатывают в обратном порядке.
- 3 привод
- 1 привод
- 6-4 приводы.

//+++++++++++++++++++++++++++++++++++++++
18.06.2021
Переписал ф-цию
void move_servo_together (byte *pos, byte start_servo, byte end_servo)
Чтобы можно было разделить движение робота на 2-3 этапа - так кубик не задевается.

Попутно пришлось переписать ф-цию  get_max_delta(delta, start_servo, end_servo)

Теперь очередь за нейронкой.
//+++++++++++++++++++++++++
19.05.2021
Добавил описание фьюзов в файле

original_fuses.txt
НАдо будет прописать фьюз для eeprom, чтобы память не стиралась каждый раз при заливке, т.к. имеет ограниченное число циклов перезаписи.

Считал фьюзы с платы NANO(НЕ Old Bootloader) и они отличаются от платы, купленной в MCU store

# avrdude -p m328p -c usbasp -P usb -n

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.00s

avrdude: Device signature = 0x1e950f (probably m328p)

avrdude: safemode: Fuses OK (E:FD, H:DA, L:FF)

avrdude done.  Thank you.

root@EvKuz-Ub-406b:/home/evkuz# avrdude -p m328p -c usbasp -P usb -n

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.00s

avrdude: Device signature = 0x1e950f (probably m328p)

avrdude: safemode: Fuses OK (E:FD, H:DE, L:FF)

avrdude done.  Thank you.
============================================
Видим, что здесь H = DE, вместо H = DA

E = 1110
A = 1010

Разница в размере области загрузки.


//++++++++++++++++++++++++
14.05.2021
Приехал программатор USBasp, пробуем подключить.
http://www.fischl.de/usbasp/

Удалось его запустить на компе в Универе.
Важно, что перед этим надо подключить к USBasp целевую плату, (у меня это NANO) и правильно указать partno (atmega328p).

avrdude -p atmega128 -c usbasp -P usb -n

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.00s

avrdude: Device signature = 0x1e950f (probably m328p)
avrdude: Expected signature for ATmega128 is 1E 97 02
         Double check chip, or use -F to override this check.

avrdude done.  Thank you.

=======================================
Видим, что неправильно ввел partno - atmega128, а надо m328p(для atmega328p)
Исправляем, получаем :
$ avrdude -p m328p -c usbasp -P usb -n

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.00s

avrdude: Device signature = 0x1e950f (probably m328p)

avrdude: safemode: Fuses OK (E:FD, H:DA, L:FF)

avrdude done.  Thank you.
=======================================
Теперь можем даже изучать Fuses.

==================================
Считаем текущую прошивку
 avrdude -p m328p -c usbasp -P usb -U flash:r:/home/localstudent/learm/m328pchip_flash_dump.hex:i

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.00s

avrdude: Device signature = 0x1e950f (probably m328p)
avrdude: reading flash memory:

Reading | ################################################## | 100% 8.39s

avrdude: writing output file "/home/localstudent/learm/m328pchip_flash_dump.hex"

avrdude: safemode: Fuses OK (E:FD, H:DA, L:FF)

avrdude done.  Thank you.
=============================
У нас появился файл с прошивкой, т.е. avrdude работает !






//+++++++++++++++++++++++++
12.05.2021

Задача :

Управление роботом состоит из ф-ций, дающих задание роботу вида "Встань в позицию коня" или "Конь пьет".
Каждая такая ф-ция сначала определяет текущую позицию робота, далее вычисляет приращения, которые следует добавить каждому из серво-двигателей.
И далее - посылает эти приращения каждому из серво-приводов.

Приращения могуть быть как в "+" так и в "-"

1. Сначала создадим *.h файл с параметрами серво, соответствующими каждой позици робота.


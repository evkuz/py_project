#ifndef WORKFLOW_PY_CALIBRATION_H
#define WORKFLOW_PY_CALIBRATION_H
/*
 * Работаем с файлом calibration.py 
 *
 *
 * Сброс компорта
 * # tput reset > /dev/ttyACM0
 *
 *
 *  Возможные статусы робота
 *  - "calibrating" - Поиск минимальной скорости для начала вращения колеса в режиме на вису.
 *  - "calculate" - В процессе выполнения "calibrating"
 *  - "done" - команда от ПК выполнена(завершена)
 *  - "waiting" - команду отправили, но ответ о завершении еще не пришел. ПОтоки всеравно крутятся.
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 20.11.2023
 * - Добавим контроль за сменой знака dltE. Значит надо хранить предыдущее значение dltE
 *
 * - Индикатор такой : Е сохраняет знак а dltE - меняет (значит больше не надо включать u, смотрим динамику значений)
 *
 * - Пока включил только проверку на попадание E в encodersGAP. Стало лучше - 1 раз из 5 Е > 200 (456)

 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 31.10.2023
 * - Смена отстающего и опережающего колес запаздывает на 2-3 цикла ПИД !!!
 *   Должно сразу срабатывать.
 *   ...
 *   Разобрался.
 *   Это происходит потому, что смена ролями у колес происходит в процессе движения. Т.е. одно колесо постепенно "догоняет" другое.
 *   При этом, в самый момент смены ролей,  РАЗНИЦА  в показаниях энкодеров незначительная. А значит, мы не заходим в pid(),
 *   где переписываются значения указателей "отстающий"/"догоняющий" (!!!)
 *   И текущая команда остается "pid", но проверка в loop не даёт зайти в пид.
 *
 *   Что ж теперь уберем проверку в loop() и будем каждый раз заходить в pid().
 *
 * - Старт сразу с большой E - такие старты надо отменять, счетчик сбрасывать.
 *
 * Дальнейший анализ проводим на основе файла data.csv
 * - Строки 16-19. Разобраться, почему при малых значениях E, dltE (с.17) происходит существенное изменение скорости ???
 * - Проверить соответствие столбиков Kp <--> P, Kd <--> D, Ki <--> I
 *   Данные в этих столбиках почти совпадают - это так по разному считают float-числа Ардуина и ПК ! Было сделано как раз для того, чтобы
 *   это проверить. Теперь можно столбики Kp, Ki, Kd убрать из файла, оставить только P, I, D.
 *
 * - P, I, D имеют тип double. Меняем на float, т.к. передаются из Ардуино только float значения, структура так прописана.
 *   С другой стороны значения P, I, D вычисляются на стороне ПК. Т.к. сами коэффициенты тоже есть на стороне ПК.
 *
 *   Ошибка с (-2), до (-9) логически - увеличивается, а математически - уменьшается, если E меняется сверху-вниз. Вот тут надо подумать...
 *   Т.е. если прошлое dltE тоже было <0, а модуль ошибки увеличился, то... меняем знак U (или тут должна интегральная составляющая включиться)
 *   Т.е. если на предыдущем шаге de/dt УЖЕ дало большое dltE (т.е. большое не само dltE, а ИЗМЕНЕНИЕ dltE)...
 *   Т.Е. включаем 2-ю производную от Е :)
 *
 *   Когда колеса постепенно выравниваются мы имеем малое Е и большое dltE. Вот в таких случаях U должно быть мало, а оно растет из-за
 *   большого dltE.
 *
 * -Сейчас в файл пишется I, вычисляемый на стороне ПК. Но, т.к. I влияет на U на стороне ардуино, то будем писать в файл I,
 *  который на стороне ардуино. [сделано]
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 30.10.2023
 * В процессе pid() не меняются значения posAm1, posAm2.
 * ...
 * И это именно проблема pid() !!!
 * Отключим Timer_A1, т.е. теперь время отсчитываем в loop
 *
 * - Не работает строчка
 *   *lagmSpeed = constrain(lessSpeed, speedBottomLimit, speedTopLimit);
 *   Будем вручную делать.
 *
 * - Смена отстающего и опережающего колес запаздывает на 2-3 цикла ПИД !!!
 *   Должно сразу срабатывать.
 *   ...
 *   А потому, что, из-за малого значения Е, из loop() не заходили в pid(), где происходит смена указателей "отстающий"/"догоняющий" (!!!)
 *
 *
 *
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 27.10.2023
 * Проверил по вчерашней задаче. Все норм. Тепрь пишется не модуль ошибки, а сама ошибка.
 * - Добавляем вычисление средней ошибки за набор циклов.
 * - Нужно учитывать динамику dltE, чтобы ошибка быстрее сокращалась, и при этом система не шла вразнос.
 *
 * - При вычислении среднего через mean(listValues), нужно учитывать только модуль, т.к. нас интересует именно
 *   абсолютная величина ошибки, а не её знак.
 * - Создать список min/max значений скорости для каждого колеса за цикл, и за набор циклов.
 *   тут нам поможет json-формат.
 *   Для статистики нужны следующие поля
 *   - Скорость старта
 *   - Минимальная скорость
 *   - Максимальная скорость
 *   - Мин. E
 *   - max. E
 *   Т.е. получаем список из словарей
 *
 *   НА первом же шаге PID очень сильное уменьшение скорости. Разобраться почему.
 *   Там сразу большое deltaT - 38.800254821777344,  а должно быть примерно
 *                               0.2008640021085739
 *
 *   Неправильные значения
 *   *lagmSpeed = constrain(*lagmSpeed, speedBottomLimit, speedTopLimit);
     *fwdmSpeed = constrain(*fwdmSpeed, speedBottomLimit, speedTopLimit);
     ...
     *data.lagSpeed_ptr = m1Speed;
    Надо пошаманить.


 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 26.10.2023
 * Много всего отладил.
 * - Для команды "calibration" добавить сохранение E после остановки
 *
 * Пора запускать по команде старт с учетом режима...
 *
 * - Возможно следует разделить команды "start" и "moveon", т.е. просто едем, либо едем с работающим pid
 *
 * - Нашел ключевую ошибку в данных.[поправил]
 *   В структуре есть переменная в diff, а есть E. ОБе означают разницу в показаниях энкодера.
 *   Так вот случился рассинхрон, т.к. не всегда задавалась переменная diff внутри Ардуино и на стороне ПК не diff, а E сохранялось в файл .csv
 *
 * - Снова переменная diff в Ардуино. Где-то она сохранена в файл как A1 - A2, а где-то как A2 - A1. Надо унифицировать.
 *   ...
 *   Ага, и вот тут-то мы и получаем резкий скачок из - в + и наоборот. Эврика !!!
 *
 *   Разобраться. Чуть поправил, надо запустить ПО и посмотреть данные.
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 25.10.2023
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 24.10.2023
 *
 * - Добавляем команду для задания точки отсчета скоростей. В режиме "calibration" это 10.
 *   В режиме "start", "moveon" это около 20.
 *   Команду назовём "setSpeedInit"
 *
 * - Добавляем статус "done", будет присваиваться по завершении команды от ПК, если не нужно сразу останавливать двигатели.
 *
 * - И вот мы подошли к ситуации, когда пора создавать программный конечный автомат.
 *   Есть в питоне Python State Machine https://python-statemachine.readthedocs.io/en/latest/readme.html
 *   Берем на заметку.
 *
 *
 *   В целом работает последовательность команд.
 *   Однако после setSpeedInit идет запуск "start" и почему-то сразу (через 1.2сек.) stop из-за "currCommand == finish--  and stopped NOW"
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 23.10.2023
 * Чтобы команда "calibration" завершалась через (lastPidTime + pidTime) пришлось её добавить в коде Ардуино в тот блок, где
 * включается ПИД. Что не есть удобно.
 * Надо менять код ардуино.
 *
 * Также добавлена посылка структуры данных из ф-ции старта "на вису" findStartCurrent().
 * Это позволяет фиксировать стартовую скорость на каждом цикле. Она очень часто разная.
 * А это,  в свою очередь, позволяет на стороне ПК собрать массив этих стартовых значений, взять среднее, и
 * отправить обратно в Ардуино, уже как точка отсчета для старта в режиме ПИД.
 *
 * Для вычисления среднего в python используем либу statistics, ф-ция mean(list_name)
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 20.10.2023
 * Перестало нормально выводить значения data.mytext, data.mystatus
 * Задолбался искать причину такой ошибки. Откатываюсь на предыдущую версию, там все работает.
 *
 * ga_bin_comport.py
 * binary_timer1A_Serial.ino
 *
 * Снова начинаю отсюда.
 * Основная задача - заставить работать ПИД в режиме "на вису".
 * Ранее бросил эту затею, т.к. на вису колеса вращаются быстрее и ошибка накапливается быстрее.
 * Вот для этого и вводятся разные режимы.
 *
 * Создал проекты
 * calibration.py
 * calibrating.ino
 *
 * Сначала проверяем последовательный запуск нескольких команд. [Работает !!!]
 * Добавляем команду "calibration" [Сделано]
 *
 * Теперь запускаем отдельно "calibration" - нужно отладить.
 * 1й раз запускается нормально, а на второй раз уже ошибки, крутится в другую сторону и с большой скоростью
 *
 *
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 19.10.2023
 * Далее работаем с проектом modes_platform.py
 * Соответствующий проект в Ардуино называется 2modes
 * Вводим дополнительный статус "calibrating"
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 17.10.2023
 * Переделываем проект на python для возможности работы в режимах "на вису", "на полу"
 * Режим "на вису" нам крайне важен, т.к. в этом случае мы можем запитывать робота от сети питания.
 * Соответственно, надо переделывать ПО, чтобы учитывать в каком режиме работает робот.
 * Возможно, придется делать 2 отдельных ПО для работы на полу и в этих 2-ух режимах.
 * Соответственно, предполагается, что все соответствующие параметры будут передаваться в Ардуину при установке режима командой от ПК.
 * Т.е. вводим новую команду "setMode" c 2 параметрами "Air", "Floor".
 * Далее сделаем считывание параметров соответствующего режима из файла и передачу в Ардуино.
 * Пока задаем только сам режим, а параметры этого режима Ардуина берет у себя.
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 01.08.2023
 * При записи данных в data.csv все ПИД-коэффициенты записываются с огромным количеством знаков после точки.
 * Нам столько не надо, хватит и 4.
 * Поэтому, перед записью в файл округляем до 4 знаков после точки.
 * fDeriv = "%.4f" % fDeriv
 * И стало красиво.
 * И файл меньше размером.
 *
 * Теперь задача:
 * - "подкручивать" стартовые значения, чтобы начинала ехать ровнее.
 *   В конечном итоге все упирается в стартовые значения.
 *   А вот их тоже можно генетическим алгоритмом выбирать.
 * - Добавляем функционал по поиску мин/макс значений, выводу в консоль, записи в отдельный файл.
 *   Пригодятся для отбора потомков.
 *   Критерий отбора - максимально среднее Е за все время стремится к минимуму.
 *   ...
 *   Постановка задачи - уже отдельная тема.
 * - Подобрать ПИД коэффициенты.
 *
 * Все это делаем на python
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 21.07.2023
 * Меняем код ардуино для выполнения команды
 * "setPID Kp Ki Kd Num Tfull Tpid"          [Сделано]
 * Надо подготовить платформу к настройке коэффициентов ПИД по разным методикам.
 * Для этого нужна возможность менять "на лету" коэффициенты ПИД, время движения, время действия ПИД-коэффициентов и т.д.
 * После этого перейдем к обзору методик.
 *
 * Теперь это проект ga_bin_comport.py
 * Размер посылки 107 байт.
 *
 * При запуске ga_bin_comport.py платформа стартует, двигается втечение времени Tfull, останавливется.
 * Такой цикл повторяется Num раз.
 * Запуск потоков происходит по условию  while counter < Num:
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 18.07.2021
 * Добавляем в посылку Ардуино -> ПК коэффициент Integral_k, чтобы не путать с Integral.
 * ОБщий размер теперь 64 байт.
 *
 * В команду "setPID" добавили еще 3 параметра :
 * - "Num"  Количество циклов запуска платформы
 * - "Tfull"  Время работы в мс 1 цикла запуска платформы. (по умолчанию 6000)
 * - "Tpid"   Время работы PID в мс. Это интервал, в течение которого действуют текущие ПИД-коэффициенты. По умолчанию 200.
 *
 * Т.е. теперь команда setPID имеет 6 аргументов :
 *
 * setPID Kp Ki Kd Num Tfull Tpid
 *
 * Пока протестирована передача самих чисел, реакция платформы еще НЕ протестирована.
 * Нужно менять код Ардуино.
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 13.07.2023
 * Решаем вопрос с зависанием компорта.
 *
 * - Добавляем в посылку Ардуино -> ПК коэффициенты P, D. ОБщий размер теперь 60 байт.
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 11.07.2023
 * После запуска программы она штатно закрывается, но больше не запускается.
 * Т.е. запускается, но с компортом какая-то проблема и тележка не едет.
 * Требуется перезалить прошивку в ардуино (т.е. как-то ресетнуть компорт) тогда тележка едет.
 *
 * - Получил рабочий код, в котором происходит отправка команды "setPID"
 * - Получил подтверждение, что Ардуина видит эту команду, добавляет данные от себя.
 *
 * Теперь задача передать коэффициенты.
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++++++
 * 28.06.2023
 * Настраиваем запись в файл данных, полученных от ардуино
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++
 * 27.06.2023
 * Т.к. нужно выводить отладочные данные, а передавать их через компорт - неправильно, их слишком много и
 * порт затыкается, то меняем формат передачи из Ардуино в ПК
 * Теперь передаем только двоичные данные, а на стороне ПК, делаем все вычисления,на основе полученных данных, и пишем отладочные данные в файл.
 *
 * - Часть данных выводится. Теперь задача вычислять данные для ПИД и настроить запись оных в файл.
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++
 * 15.06.2023
 * Пора попробовать обмен с компортом в 2 потока.
 * 1 поток - слушает команды пользователя из консоли, отправляет команду в компорт
 * 2 поток - считывает данные из компорта(ардуино), записывает в файл.
 *
 * Оба потока завершаем по команде из консоли "close"
 *
 * Потоки запускаются, а далее бесконечный цикл не дает им выполниться.
 * ...
 * Поправил. Потоки запускаются и завершаются в бесконечном цикле.
 * Выход из бесконечного цикла по условию (команда "close")
 * Файл данных пишется. При этом таймер в ардуине на частоте 2Гц.
 *
 * Теперь начинается самое интересное.
 * Подборка ПИД-коэффициентов.
 *
 */
#endif // WORKFLOW_COMPORT_H

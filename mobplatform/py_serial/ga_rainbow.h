#ifndef GARAINBOW_H
#define GARAINBOW_H
/*
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 21.07.2032
 * По-хорошему, конечно, надо сравнить время выполнения через ГА и через обычный перебор строки посимвольно.
 * Оставим пока на паузу.
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 20.07.2023
 * Задача выполнена.
 * Список ф-ций :
 * - genRandomString(strLen): - Генерит (возвращает) случайную строку длины strLen
 *
 * - def strModification(theText): - Возвращает модифицированную строку из строки theText.
 *   Модификация заключается в изменении случайного символа строки на случайный символ алфавита, включая пробел.
 *
 * - def fitnessFunc(theText, theSource): Принимает на вход строку-потомок и строку-предок, возвращает число совпадений (символов предка и потомка.
 *
 * - def genOffSprings(theText, numOfMatched): Возвращает словарь, где ключ - число совпадений, значение - строка-потомок
 *   для строки theText. При этом число совпадений у потомка больше, чем numOfMatched (у предка).
 *   Если в результате мутаций число совпадений у потомка меньше или равно таковому у предка, то возвращает пустой словарь.
 *   Выполняет 10 раз модификацию строки и проверку результата через ф-цию fitnessFunc.
 *
 *
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *
 * 18.07.2023
 *
 *
 *  В самом простом виде генетический алгоритм имеет следующую структуру (см. схему):
 *  - начинаем с некоторым решением, в нашем случае, это случайная строка;
 *  - вносим мутации, например, меняем случайно выбранную букву в строке на случайно выбранную букву
 *    (вначале используеи shuffle, а можно просто случайный индекс и случайный символ)
 *    и получаем новый набор строк (k мутаций на строку); из них отбираем только те, которые ближе к исходной
 *    (по количеству совпадающих символом), например 10 таких строк, если исходной среди них нет,
 *    то запускаем процесс заново.
 *
 * 1. Генерация случайного поколения особей-решений
   2. Выбор наиболее качественных особей поколения
   3. Скрещивание особей для получения их потомков (в данном случае нет)
   4. Мутация потомков
   5. Получение нового поколения

   Функция пригодности (ФП) - количество совпадаюищих с исходной строкой символов. (отбираем только те, которые ближе к исходной
  (по количеству совпадающих символом)

   Начальная популяция(набор символов) - исходная строка, перемешанная до неузнаваемости.

   Алгоритм вычисления ФП :

   1. Находим первое совпадение символов

   Формируем массив из словарей.
   В каждом словаре ключ - число совпадений всего, число совпадений более 1 символа подряд, индексы совпадающих символов

   - Прогнали мутацию строки 10 раз. Получили 10 разных строк, где есть хотя бы 1 совпадение.
   - Выбираем наилучшее поколение, снова прогоняем через мутацию
     Лучшее поколение то, где больше совпадение с исходной строкой. Если во всех поколениях одинаковое число совпадений,
     берем последнее (самое "молодое")


   В Ф-цию "def genOffSprings(theText):" надо добавить учёт количества совпадений строки ДО генерации потомка.
   ЧТобы отбросить потомка, у которого в результате мутации число совпадений будет меньше.
   В самом начале - у начальной популяции - число совпадений может быть и 0
 */
#endif // GARAINBOW_H

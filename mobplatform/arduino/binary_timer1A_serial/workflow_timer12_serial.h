Записи по проекту timer12_serial

При включении скорости 100 на 1с. имеем следующие показания М1, М2 :

АМ1 = 978
АМ2 = 1192
Ош  = 214

Либо

АМ1 = 1703
АМ2 = 2037
ОШ  = 334

AM1 = 3499
AM2 = 4125
ОШ = 626

AM1 = 5133
AM2 = 6086
ОШ = 953
/*
 * about SERIAL_TX_BUFFER_SIZE
 * https://github.com/arduino/ArduinoCore-avr/issues/177
 * 
 * 
 * //+++++++++++++++++++++++++++++++++++++++++++
 * 29.06.2023
 * Если ПИД уменьшает одно из колес так, что оно не едет, то начинается отлов этой ситуации - разница между прошлым и текущим значением равна 0.
 * Нот тут жеж колесо еще может ехать по инерции...
 * 
 * Также логический тупик.
 * Пид уменьшает скорость колеса, и если за цикл таймера колесо проезжает очень мало, то считаем, что колесо стоит.
 * А если так и нужно, чтобы колесо ехало очень медленно ? А вот не надо доводить до этого. Надо плавно менять скорость вращения.
 * 
 * Почемуто обнулилось. Т.е. случился stop
 * 
 * posA1= 493, posA2= 493, E= 0, Eprev= 14, m1Speed= 75, m2Speed= 107, dltE= -14
   diff_posAm1= 30, diff_posAm2= 44, millis = 24761, delta_T = 1234.5677490234375, de/dt = 0.7210000157356262, P = 0.0, py_dedt = -0.011340001398120289, I = 0.0, D = -0.0005670000699060145, u = 0

   posA1= 157, posA2= 182, E= -25, Eprev= 0, m1Speed= 94, m2Speed= 94, dltE= -25
   diff_posAm1= -336, diff_posAm2= -311, millis = 28317, delta_T = 1234.5677490234375, de/dt = 0.7210000157356262, P = -3.75, py_dedt = -0.020250002496643375, I = 0.0, D = -0.0010125001248321689, u = 4

Между записями 4с. Т.е. 

...
В целом ездит правильно. 
Теперь строим график E(t), смотрим, как "плавает" вверх-вниз ошибка.
   

 * 
 * 
 * //++++++++++++++++++++++++++++++++++++++++++++
 * 28.06.2023
 * Обращаем внимание, на первые 2 шага нашего  ПИД ( это 4 строчки лога)
 * 
 *posA1= 2070, posA2= 2110, E= -40, Eprev= -39, m1Speed= 73, m2Speed= 73, dltE= -1
 diff_posAm1= 2070, diff_posAm2= 2110, millis = 20945, delta_T = 0.12455199658870697, de/dt = -8.028775215148926, P = -10.0, py_dedt = -8.028775349962308, I = -0.004982079863548279, D = -0.4014387674981154, u = 10

posA1= 2463, posA2= 2418, E= 45, Eprev= 38, m1Speed= 83, m2Speed= 63, dltE= 7
 diff_posAm1= 393, diff_posAm2= 308, millis = 22821, delta_T = 0.12455199658870697, de/dt = 56.2014274597168, P = 11.25, py_dedt = 56.20142744973616, I = 0.0006227599829435349, D = 2.8100713724868083, u = 14

Время прошло почти 2 секунды !!! 
И все убежало за это время...

 * 
 * 
 * 
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 27.06.2023
 * Создадим отдельную ф-цию для команды "start".
 * Будем вызыват её, если под действием PID тележка останавливается.
 * 
 * //++++++++++++++++++++++++++++++++
 * 22.06.2023
 * Нужно отладить через SerialMonitor Arduino вывод float значений delta_T и dedt. [Сделано]
 * При передаче через ком-порт есть фича в том, что данные приходят в bigendian формате, а это float число.
 * И как его правильно декодировать ?
 * Поэтому в сериал мониторе посмотрим сами float значения.
 * А потом разобраться, как это передать питону.
 * 
 * Есть ошибка в логике.
 * Если u<0, то оно все равно прибавляется к отстающему колесу, и оно отстает еще больше
 * И отрицательное значение вычитается из опережающего, т.е. оно в итоге опережает еще больше.
 * 
 * Т.е. коэффиценты ПИД должны быть такие, чтобы для отстающего колеса всегда было положительное u.
 * Нужна взаимосвязь меджу Kp и текущей скоростью. Если скороть больше, то и Kp должен быть больше.
 * 
 * - Поставил ограничение на величну u, чтобы колеса не разгонялись слишком.
 * 
 * В общем, надо разобраться со знаком для u
 * Если колесо m1 отстает, то E<0, что приводит к u<0
 * B de/dt < 0 при уменьшении E, т.е. E < Eprev
 * 
 * Получается, что P вносит меньшее воздействие, чем D. А это правильно ?
 * 
 * 
 * 
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 21.06.2023
 * - Добавляем в структуру данных время, пока в millis() [Сделано]
 * - Добавляем регулировку через ПИД
 * 
 * u(t) = round((float)Kp*E(t) + (float)Ki*I + (float)Kd*dedt); // Управляеющее воздействие...  
 * 
 * E(t) = разница между posA1 posA2
 * Соответственно Коэффициент Kp должен быть связан с величиной ошибки и скоростью
 * Помним, что на скорости 100 совершаем 1 оборот за 1с. А таймер у нас срабатывает каждые 500мс.
 * 
 * Se(t)dt  = Eint + Edt
 * dedt = (E - Eprev)dt
 * 
 * Надо ввести параметр - скорость вращения. Это число оборотов за ед. времени. у нас это число оборотов относительно числа в счетчике таймера.
 * Оно разное в зависимости от скорости.
 * 
 * mxA - число отсчетов за 1 оборот
 * N = 1 оборот за 1с. на скорости 100, тогда на скорости 200 N = 2. Значит имеем формулу подсчета количества оборотов за данное
 *       время на определенной скорости:
 * 
 * N = (currSpeed/refSpeed)*(deltaT(ms)/1000), где
 * - currentSpeed - текущая скорость
 * - refSpeed - скорость, относительно которой считаем,  - базовая или референсная
 * - deltaT(ms) - время в мс, за которое считаем.
 * 
 * Соответственно, это число N - связано с величиной ошибки.
 * Ошибку E считаем в отсчетах энкодера. Е связано с N 
 * 
 * Чем больше Е относительно mxA, тем больше нужно управляющее воздействие.
 * 
 * Попробуем отказаться от идеи учесть все зависимости в одном коэффициенте П.
 * По самой идее пида П - пропорционален текущей ошибке, а 
 * Д - учитывает скорость изменения ошибки, и вот тут, наверное, надо учесть величину поворота колеса относительно полного 
 *     оборота в зависимости от скорости.
 * 
 * Уже остро чувствуется необходимость использовать git...
 * 
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 23.06.2023
 * Нужно поймать момент, когда при текущих значениях скорости колеса поворачиваются на одинаковое значение энкодеров.
 * 39 - порог скорости, при котором тележка встает и больше не едет.
 * 
 * Задача :
 * Добавить в обработчик таймера проверку, что если ПИД не запускается, то сравнить показания энкодера между текущим значением
 * и предыдущим для каждого колеса, и если разница 0, значит колесо стоит ! итогда увеличиваем ток !
 *
 * 
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 20.06.2023
 * - Колёса стартуют не одновременно, это четко видно. Даже при очень плавном пуске.
 * - При плавном пуске, если одно колесо стартует раньше, то второе может и не запуститься, т.к. для этого - второго всеравно не хватает тока.
 *   Тут должен включаться ПИД !
 * - Сделал очень плавный пуск. Ф-ция MoveIfStopped()
 *   Выяснилось, что при движении со скоростью примерно 75 (очень медленно, но едет !) на определенных участках пола
 *   настолько неровно, что тележка не может ехать.
 *   Поэтому ф-ция MoveIfStopped() добавлена в запуск из таймера по логическому флагу "startFlag"
 * - Ждем теста на полиогне. Сел аккум для Jetson NANO
 * - Даже при медленном движении тележка смещается из-за М1, которое крутится чуть быстрее. Разница в показаниях меньше 20.
 * - Переделал обмен с ПК. Теперь в посылке для ПК только численные данные, без строк. Это всего 12 байт, которые в Ардуино
 *   упакованы в структуру
 *   struct Enc {
        word A1_Enc;
        word A2_Enc;
        short diff;
        short diff_vector;
        int M1_Speed;  // Не более 255, знаем. Штатное значение - 100, поэтому для "торможения" или "обгона" 255 должно хватить 
        int M2_Speed;
        
      };
 * 
 * 
 * 
 * 
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 19.06.2023
 * Включаем связь П-коэффициента с ошибкой.
 * 
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 16.06.2023
 * Заливаем скрипт из ПК в тележку:
 * 
 * rsync -av /home/ubuntu/pyprojects/mobplatform/py_serial/bin_comport.py nvidia@192.168.1.176:/home/nvidia/pyprojects/mobplatform/py_serial/
 * 
 * После срабатывания условия в процедуре pid() перестаёт изменяться знечение энкодера А1.
 * При этом колесо крутится.
 * ...
 * А это потому что неправильно вычислялась строчка
 * 
 * delta = abs(abs(posAm1 - posAm2) - encodersGAP);
 * 
 * Которая выдавала отрицательные значения для delta
 * Пришлось разделить на 2 строчки :
 * 
 * delta0 = abs(posAm1 - posAm2);
 * delta = abs(delta0 - encodersGAP);
 * Так стало правильно вычислять delta
 * 
 * Также есть разница между строкой, выводимой по таймеру из ф-ции getValues() :
 * posAm1=7017, posAm2=6814, diff=203, diff_prev=376, VectorDiff=173, m1Speed=125, m2Speed=195
 * 
 * И строкой из ф-ции pid()
 * 
 * delta=173
 * Но в pid() еще отнимается encodersGAP, который равен 30, так что все сходится (см. выше строку для delta).
 * ...
 * 
 * Теперь колеса друг за другом "гоняются", то 1е за 2ым, то 2е за 1ым.
 * Вот тут надо включать полноценный PID.
 * Т.е. чем больше отставание, тем больше коэффициенты. Когда отставание сокращается, коэффициенты также должны меняться.
 * Сейчас действует только П-коэффициент, а пора добавлять Д, И, коэффициенты.
 * 
 * Пора сохранять на git
 * //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 15.06.2023
 * /home/ubuntu/.arduino15/packages/arduino/hardware/megaavr/1.8.8/cores/arduino/UART.h
 * 09.06.2023
 * Стандартная проблема ком-порта в Ардуино - размер буфера Tx - 32 байта.
 * Поэтому, когда идет передача данных от Ардуино в ПК вся посылка разбивается на порции по 32 байта.
 * В текущем проекте строка вывода примерно такая :
 * posAm1=90647, posAm2=92754, diff=-2107, diff_prev=-2108, VectorDiff=1, m1Speed=60, m2Speed=60
 * это 93 символа, или 4 посылки
 *
 * 07.06.2023
 * Алгоритм настройки ПИД-коэффициентов
 *
 * - Определяем число отсчетов за 1 цикл работы таймера
 * - Вычисляем разницу в показаниях энкодеров для каждого колеса за 1 цикл работы таймера
 *   Смтотрим, линейно ли меняется это число при 2-3-4 и т.д. циклах таймера (это уже много кода на питоне)
 * - Вычисляем коэффициент П для отстающего колеса
 * 
 * 
 * 
 */

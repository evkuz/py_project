#ifndef WORKFLOW_MOB_PLATFORM_H
#define WORKFLOW_MOB_PLATFORM_H
/*
 *  
 * 18.10.2022
 * Запускаем мобильную платформу.
 * Работаем с DC-двигателями (моторы) Pololu #4752
 * https://www.pololu.com/product/4752
 *
 * Для питания этих двигателей используем шилд
 * Pololu Dual VNH5019 Motor Driver Shield for Arduino
 * https://www.pololu.com/product/2507
 *
 * Двигатели запускаем на токе М1 = 100, М2 = (-100)
 *
 * Так вот данные с энкодеров А и В разные для М2 !!!
 *
 * Для М1 данные с энкодеров примерно одинаковы.
 * posAm1 26956
 * posBm1 26957 z
 * А для М2 - разные !
 * posAm2 -20629
 * posBm2 29392
 * Вообще, мотор М2 крутится дольше, чем М1. Поэтому и число posBm2 больше, чем posBm1. 
 *
 * Данные по одометрии.
 * НА свежем аккумуляторе
 * 
 * smooth_speed=90
 * 
 * 1 rotation forward comes at i=68
 * 1 rotation backward comes at i=70
 * 
 * rostopic echo /encoders | tee encoders.txt
 * 
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 26.01.2023
 * ПИД запускается внутри обработчика таймера, независимо от команды.
 * ТАк у нас скорость колес постоянно корректируется.
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 25.01.2023
 * Зависание происходит в ф-ции goToPid().
 * Если эту ф-цию убрать из прерывания, то все нормально работает (но без ПИД-регулировки)
 * Ищем, где-конкретно затык.
 * ...
 * 
 * После установки кода
 * if ((abs)(m1Speed - m2Speed) > 50){ 
   m1Speed = defaultMSpeed;
   m2Speed = defaultMSpeed;
  }

  Скорость перестала меняться вообще :)
  Может это и есть нужный нам результат ?
  Надо проверить как едет
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 23.01.2023
 * Короткие команды "start", "stop" работают отлично. НО они и не требуют выполнения обработки прерывания. 
 * А вот команда "mkrotation" попадает в обработку прерывания, а оттуда в вычисление ПИД. Т.е. это длительная процедура.
 * Скорее надо сделать так, чтоб вычисление ПИД-скорость   крутилось в основном цикле, а по прерыванию только менялась скорость.
 * 
 * Будем глубже раскуривать rosserial
 * 
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 27.12.2022
 * 
 * Ф-ция mkrotation() и ф-ция goToPID() вместе мешают друг другу.
 * mkrortaion(число_оборотов) вызывается в loop(), проверяет текушие значения энкодеров и по ним определяет, достигнуто ли нужное число оборотов.
 * Если достигнуто - возвращает 0, если еще нет, то 1.
 * 
 * goToPID() вызывается по прерыванию таймера, сверяет разницу в показаниях энкодеров и через PID-регулировку меняет значения скоростей.
 * И вот эти две ф-ции мешают жить друг другу :)
 * 
 * Убрал вызов mkrotation() из loop(), поместил их обе в ISR (Interrupt Service Routine)
 * 
 * Теперь вижу, что заходит в goToPID(), выполняет все действия, выходит из goToPID(), выходит из ISR и на этом связь по Serial Port отваливается.
 * Как вариант разобраться с предупреждениями компилятора
 * 
 * /home/nvidia/Arduino/Pololu_VNH5019_EK/Pololu_VNH5019_EK.ino:95:63: warning: invalid conversion 
 * from 'void (*)(std_msgs::String)' to 
 * 'ros::Subscriber<std_msgs::String>::CallbackT {aka void (*)(const std_msgs::String&)}' [-fpermissive]
 ros::Subscriber<std_msgs::String> sub("mobplatform", messageCb);
                                                               ^
In file included from /home/nvidia/Arduino/libraries/ros_lib/ros/node_handle.h:60:0,
                 from /home/nvidia/Arduino/libraries/ros_lib/ros.h:38,
                 from /home/nvidia/Arduino/Pololu_VNH5019_EK/Pololu_VNH5019_EK.ino:6:
/home/nvidia/Arduino/libraries/ros_lib/ros/subscriber.h:107:3: note:   initializing argument 2 of 'ros::Subscriber<MsgT, void>::Subscriber(const char*, ros::Subscriber<MsgT, void>::CallbackT, int) [with MsgT = std_msgs::String; ros::Subscriber<MsgT, void>::CallbackT = void (*)(const std_msgs::String&)]'
   Subscriber(const char * topic_name, CallbackT cb, int endpoint = rosserial_msgs::TopicInfo::ID_SUBSCRIBER) :
   ^~~~~~~~~~

Смотрим ros tutorial 
http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(c++)

   
 * 
 * nh.spinOnce(); ???
 * 
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 21.12.2022
 *  Формула рассчета ошибки Е в числе оборотов колеса должна быть безразмерна, а у меня она получается размерностью 1/с, хотя может быть сверху
 *  стоит 1с - примерное время одного оборота колеса НА СКОРОСТИ ПО УМОЛЧАНИЮ, тогда все будет правильно, безразмерная величина.
 *  Порог отсчетов - допустимая разница в числе отсчетов, поэтому всегда смотрим, насколько она превышена.
 *  
 *  Rel_1 = [(число отсчетов за время dt) - (порог)] / (число отсчетов за 1 оборот)
 *  Rel_2 = (dt - время дискретизации)/(время 1 оборота, примерно 1с)
 *  Rel_3 = (текущая скорость)/(скорость по умолчанию)
 *  
 *  Есть путаница между  понятиями P и E в терминах PID, надо с этим разобраться.
 * 
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 02.12.2022
 * Когда относительная ошибка (прошлая ошибка) меняет знак, значит отстающее колесо уже обогнало опережающее, и они поменялись местами.
 * Сейчас они продолжают увеличивать скорость, а надо как раз в этой точке скорость сбрасывать для обоих колес.
 * 
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 01.12.2022
 * Отстающее колесо ускоряется, обгоняет, затем его начинает догонять отставшее, и это приводит
 * к постоянному росту скорости.
 * ВВодим понятие "опережающее колесо". Нужно отслеживать, когда они меняются и в этот момент
 * сбавляем скорость обогнавшего и увеличиваем скорость отстающего.
 * Т.е. в ПИД будем одновременно замедлять опережающее и ускорять отстающее.
 * ...
 * Учитывать для каждого колеса именно ЕГО (этого колеса) коэфиициент MxA_k - число отсчетов энкодера на 1 оборот.
 * ...
 * Вводим в рассчеты dt, т.к. D-составляющая зависит от него.
 * Задача:
 * - Добавляем D-составляющую в рассчет PID.
 * Вся работа PID теперь будет в одной ф-ции goToPID().
 * Добавил расчет для отстающего колеса.
 * На очереди опережающее
 * ...
 * Сделано.
 *
 * Видно, что идем в правильном направлении.
 * Бывают вполне прямые 1-кратные проезды. Тестировал 3-5 оборотов.
 * Много времени провозился выясняя, что не работает строчка
 *
 * double TRC = 1/timerPerRotation;
 *
 * А так работает
 * double TRC = (double)1/timerPerRotation;
 *
 *
 * Баги:
 * - Всегда, если уезжает, то влево.
 * - Всегда идет рост скорости.
 * - Бывает скачкообразный рост скорости, сразу на 120, например.
 * - ROS почти после каждого проезда теряет связь с Serial портом. Все время приходится перезапускать ROS.
 *   Может укоротить строки вывода ? (до 32 байт)
 *
 * ...
 * Есть файл вывода со всеми цифрами. Будем выяснять, почему так резко меняются иногда.
 *
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 30.11.2022
 * Установим таймер на 0.5 сек., чтобы быстрее реагировать на несоответствие в данных энкодеров.
 * Задача:
 * - Добавить опцию включения таймера, отслеживающего данные с энкодеров только при определенных командах.
 *   Во всех остальных командах следует таймер держать выключенным, дабы экономить ресурсы.
 *   Сейчас таймер включен постоянно и запускает корректировку скорости только если есть соответствующая команда
 *
 *
 * Наблюдаем, что при текуших настройках таймера и на 3 оборотах
 * наша корректировка скорости запускается 3 раза
 * 46-44-24-18
 * Если разница меньше 20, то считаем, что колеса одинаково повернтуы
 * ...
 * Вот не совсем верно.
 * Разница в оборотах все время должна стремиться к GAP.
 * Если разница существенно меньше, то, значит, мотор М2 работает сильнее, т.к. обычно он отстает
 * Вот за этой скоростью изменения и будем следить.
 *
 * Также помним, что у нас скорость после выравнивания остается по-прежнему выше (100-125)...
 * Это надо скорректировать
 *
 * Вот такая засада
 *
 *data: "diffAbsolute = -49, diffRealative = -51"
---
data: "Making speed regulation"
---
data: "Current mxA_k is 475"
---
data: "backlog value as double is -0.1032, speed delta value as double is -10.3158"
---
data: "newSpeed value as int is 90"

Надо совершенствовать алгоритм, добавлять I, D составляющие.
Сейчас сначала скорость увеличивает, а потом уже другое колесо надо корректировать.

 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 29.11.2022
 * 
 * Задача :
 * - вычислить время, между началом запуска команды и вызовом ф-ции stop()
 *   "НА вису", т.е. когда колеса вертятся в воздухе, а не едут по земле это 1474мс.
 *   "на земле" - это 4920мс
 *   
 * Задача:
 * - Передавать из топика команду с аргументами. Так можно будет задавать число оборотов колеса и сравнить время на 1,2,5,10 оборотов. [Done]
 * 
 * Задача:
 * - Добавить в список команд "setspeedM1", "setspeedM2". Так можно будет задавать скорость вручную.
 * 
 * Найти строки, начинающиеся с 'data: "Reached ' и следующую строку, вывести эти строки в файл data.txt. Остальное из вывода удалить.
 * Исходный файл останется без изменений.
 * sed -e '/^data: \"Reached/, +1!d' encoders.txt >> data.txt
 *  
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 28.11.2022
 * Выполняем калибровку колес.
data: "M1_A 448"
---
data: "M1_B 446"
---
data: "M2_A 463"
---
data: "M2_B 463"
---
...
data: "M1_A 482"
---
data: "M1_B 478"
---
data: "M2_A 494"
---
data: "M2_B 496"
---
...
data: "M1_A 470"
---
data: "M1_B 469"
---
data: "M2_A 492"
---
data: "M2_B 494"
#####################################
reverse
data: "M1_A 484"
---
data: "M1_B 485"
---
data: "M2_A 479"
---
data: "M2_B 480"
---
...
data: "M1_A 484"
---
data: "M1_B 484"
---
data: "M2_A 487"
---
data: "M2_B 487"

Создаем ф-цию, поворачивающую колесо на заданное число оборотов.
При достижении заданного числа оборотов генерим прерывание, где останавливаем платформу.
 * 
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 25.11.2022
 * Выяснилось, что при использовании usb-хаба начинают конфликтовать лидар и ардуино.
 * Поэтому ардуино осталась на хабе, а лидар напрямую в крайний из 2 разъемов usb.
 * Из-за неровностей пола платформа всёравно начинает слегка сворачивать, поэтому пра программировать PID.
 *
 * Задача :
 * - Запуститить прерывание по таймеру (1раз/сек.), выводить значения энкодеров в serial port
 *
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 24.11.2022
 * Имеем следующие команды управления
 * - "start". "stop", "rear", "left", "right" - просто движение согласно команде, без пауз.
 * - "moveit", "moveback" - 1 оборот колеса вперед, либо назад.
 * 
 * Наша программа должна принимать команду на движение и ждать следующие команды - замедление, поворот, остановка, задний ход.
 * Добавляем ф-ции
 * decSpeed, incSpeed - соответственно, уменьшение, увеличение скорости.
 * Этим ф-циям соответствуют команды "slowdown", "faster"
 * //+++++++++++++++++++++++++++++++++++++++++++++++
 * 23.11.2022
 * НА сегодня имеем
 * 1. Запускаем пакет rplidar_ros, получаем карту местности в RVIZ
 *    roslaunch rplidar_ros view_rplidar.launch
 *    
 * 2. Имеем каркас пакета 
 *    rosrun robot_setup_tf tf_listener
 *    rosrun robot_setup_tf tf_broadcaster
 *    
  *    
 * 
 * //+++++++++++++++++++++++++++++++++++
 * 22.11.2022
 * Go on with ros navigation tutorial
 * http://wiki.ros.org/navigation/Tutorials
 *
 * Now make "Transform Configuration"
 * http://wiki.ros.org/navigation/Tutorials/RobotSetup/TF
 * $ cd %TOP_DIR_YOUR_CATKIN_WS%/src
 * $ catkin_create_pkg robot_setup_tf roscpp tf geometry_msgs
 * $ nano src/tf_broadcaster.cpp 
 * 
 * The next step is to replace the PointStamped we used for this example with sensor streams that come over ROS.
 * http://wiki.ros.org/navigation/Tutorials/RobotSetup/Sensors
 * 
 * 
 * //+++++++++++++++++++++++++++++++++++
 * 09.11.2022
 * В прокете РОС-пакета mobplatform  создал папку scripts/, а в ней скрипт movingPlatform.bash
 * Который в качестве единственного аргумента принимает команду, которая идет в топик mobplatform в качестве аргумента
 * Путь 
 * ~/catkin_ws/src/mobplatform/script
 * 
 * Запуск
 * ./movingPlatform.bash start|stop|rear|moveit|reset|moveback
 * 
 * Теперь задача - подклчюить лидар  A1M8-R5
 * 
 * RPLIDAR A2M6-R4 S/N: C4939AF2C1EA98D4BEEB9CF04B403517
 * 
 * 
 * //+++++++++++++++++++++++++++++++++++
 * 08.11.2022
 * Создал каркас для запуска платоформы как ROS пакета. Пакет называется mobplatform.
 * 
 * Запускается командой 
 * $ roslaunch mobplatform mobplatform.launch
 * Соответствующий launch-файл: ~/catkin_ws/src/mobplatform/launch/mobplatform.launch
 * 
 * Пора сохранять в git папку  ~/catkin_ws/src/
 * Далее наращиваем функционал пакета mobplatform.
 * 
 * Нужно добавить запуск платформы по команде из tcp/ip
 * Создаем в python аналог QTcpServer 
 * 
 * По 1-му скрипту на каждую команду ?
 * 
 * 
 * //+++++++++++++++++++++++++++++++++++
 * 07.11.2022
 * Задача:
 * - По нажатию кнопки клавиатуры отправлять сообщение "start/stop/rear/moveit/moveback/reset/get_vslues" в топик "mobplatform"
 * 
 * Для вычисления расстояни, пройденного роботом вводим понятия :
 * - Пройденное каждым колесом расстояние. Хранится в виде количества оборотов колеса в штуках.
 * - Текущая скорость вращения колеса в единицах силы тока в диапазоне (-400; 400)
 * - Текущая скорость вращения колеса в радианах в секунду (!)
 * 
 * Объединить запуск ROS node
 * - rosrun rosserial_python serial_node.py /dev/ttyACM0
 * - rostopic pub "mobplatform" std_msgs/String "start/stop/rear/moveit/moveback/reset/get_vslues" --once
 * 
 * 
 * 
 * 
 * Задача :
 * - Передавать в сообщения std_msgs/Float64 расстояния, пройденные колесами
 * - Передавать в сообщения std_msgs/Float64 текущие скорости вращения колес.
 * - Публиковать эти сообщения в соответствующие топки (определиться с названиями топиков)
 * - Настройка PID-контроллера для управления скоростью вращения колес.
 * 
 * 
 * //+++++++++++++++++++++++++++++++++++
 * 02.11.2022 
 * После отключения тока от двигателя колесо еще по инерции крутится какое-то время.
 * Поэтому не происходит полное обнуление счетчиков.
 * Надо, кстати, проверить обнуление после завершения ф-ции stop(), только после неё ток отключается.
 * Поэтому счетчики обнуляются в самом начале ф-ции однократного движения move_fwd.
 * Так гарантировано происходит однократное движение.
 *  
 * //+++++++++++++++++++++++++++++++++++
 * 01.11.2022
 * Предполагаемый набор ф-ций для движения мобильной платформы :
 * - вперед, назад равномерно с заданной скоростью
 * -
 * - поворот направо, налево с заданной скоростью
 * - Алгоритм, математика для планирования маршрута
 * - Добавление тока(скорость), если поверхность трудно проходима.(т.е. тут надо проверять, сдвинулся ли хотя бы на четверть оборота)
 *

//+++++++++++++++++++++++++++++++++++++
31.10.2022
Разобрался почему не едет. Потому, что знает, что сделала уже 1 оборот :)
НАдо засылать ресет, тогда можно еще один оборот проехать.
Т.е. надо доработать коэфффициенты m1A/B_k чтобы оба колеса поворачивались на 1 оборот.
 Сейчас разница видна невооруженным взглядом.
При этом данные с энкодеров :
data: "m1_count 0.9228"
---
data: "m2_count 1.0053"

Т.е. м1 не доворачивает на 0.08 - и это видно глазом !
В общем, работаем, подбираем коэффициенты.


//+++++++++++++++++++++++++++++++++++++
28.10.2022

cd /home/nvidia/iqr_lit
rsync -ar arduino_mega/mobPlatform/Pololu_VNH5019_EK /home/nvidia/Arduino/
sed -i '/^---/d' encoders.txt
rsync -ar /home/nvidia/Arduino/Pololu_VNH5019_EK arduino_mega/mobPlatform
 Провел калибровку значений энкодеров для 1 полного оборота колеса.
В процессе отладки, т.к. сел единственный рабочий аккумулятор.
 * //+++++++++++++++++++++++++++++++++++++
 * 27.10.2022
 * Поменял subscriber "toggle_led" на "mobplatform"
 * ...
 *
 * Поменял publisher "chatter" на "encoders"
 *
 * Также мотор М2, у которого сильно (несколько сотен) различались значения энкодеров А и В, посадил на прерывания с ножками 20, 21 (вместо 2,3)
 * И вот так значения А и В отличаются всего лишь на 2.
 * Следующим номером калибруем, сколько отсчетов даст энкодер на 1 оборот каждого из 2 колес.
 * И начинаем полноценную одометрию.
 * По размеру колеса и количеству его боротов рассчитываем расстояние пройденное роботом.
 *
nvidia@tegra-ubuntu:~$ rosrun rosserial_python serial_node.py /dev/ttyACM0
[INFO] [1666884337.376983]: ROS Serial Python Node
[INFO] [1666884337.417194]: Connecting to /dev/ttyACM0 at 57600 baud
[INFO] [1666884339.532458]: Requesting topics...
[INFO] [1666884339.572045]: Note: publish buffer size is 512 bytes
[INFO] [1666884339.578394]: Setup publisher on encoders [std_msgs/String]
[INFO] [1666884339.598692]: Note: subscribe buffer size is 512 bytes
[INFO] [1666884339.604493]: Setup subscriber on mobplatform [std_msgs/String]

 * //+++++++++++++++++++++++++++++++++++++
 * 20.10.2022
 * Нужный функционал получен.
 * Подключаем ардуино либу #include "DualVNH5019MotorShield.h"
 * Создаем объект класса DualVNH5019MotorShield :
 * DualVNH5019MotorShield md;
 *
 * Создаем нодХолдер - объект класса  ros::NodeHandle:
 * ros::NodeHandle  nh;
 *
 * Создаем "публикователь" сообщений типа String, который в ROS будет виден как encoders:
 * std_msgs::String str_msg;
 * ros::Publisher chatter("encoders", &str_msg);
 *
 * Создаем "подписчика" на сообщения типа std_msgs::String топика "tofggle_led" из ROS :
 * ros::Subscriber<std_msgs::String> sub("toggle_led", &messageCb );
 *
 * Топик "toggle_led" - посылаем строковые команды(из ROS).
 * "toggle_led" - задается в ROS
 * Внутри ардуино мы подписываемся на этот топик
 *
 *
 * ros::Subscriber<std_msgs::String> sub("toggle_led", &messageCb );
 * ...
 * setup {
 * ...
 * nh.subscribe(sub);
 * ...
 * }
 * Данные с этого топика обрабатывает ф-ция messageCb.
 * Внутри ф-ции messageCb считываем данные из топика :
 *
 * currCommand = toggle_msg.data;
 *
 * Внутри loop парсим команду и вызываем соответствующие ф-ции
 * if (currCommand == "start") {
 *     forward();
 * }
 *
 * ....
 *
 * Для отправки данных из ардуино в serial port и далее в ROS создаем через нодХолдер
 * nh.advertise(chatter);
 * Для отправки в сериал порт кладем данные в переменную data и публикуем:
 *
 * str_msg.data = char_BM1_array;
 * chatter.publish( &str_msg );
 *
 *
 *
 * Также внути ардуино создаем
 * publisher "toggle_led"
 *
 * Задача :
 * Поменять топик "toggle_led" на "movingON". [Сделано]
 *
 * //++++++++++++++++++++++++++++++++
 * 19.10.2022
 * Запускаем связку ROS<--->Arduino.
 * Нам необходимо наладить обмен данными между ROS и  Arduiono через serial порт.
 *
 * Задача минимум :
 * - Отправляем из ROS в serialport  команду "start". Робот ловит эту команду и запускает работу
 *   двигателей в заранее заданном режиме. При этом робот начинает выдавать в serial port 
 *   значения  энкодеров для обоих двигателей. [Сделано]
 *
 * - Отправляем из ROS в serialport  команду "stop". Робот останавливает двигатели, ждет новую    
 *   команду.[Сделано]
 *
 * Для запуска мобильной платформы из ROS выполняем следующие команды:
 * В новом терминале
 * roscore
 *
 * В новом терминале
 * rosrun rosserial_python serial_node.py /dev/ttyACM0
 *
 * В новом терминале   ЗАПУСК платформы
 * rostopic pub "mobplatform" std_msgs/String "start" --once
 * 
 * В новом терминале СТОП платформы
 * rostopic pub "mobplatform" std_msgs/String "stop" --once
 * 
 * Проверить работу топика можем так
 * в новом терминале
 * rostopic echo /encoders
 *
 * Задача :
 * Считываем данные, посылаемые из arduino в ROS [почти]
 * Смотрим данные топика encoders
 * rostopic echo /encoders
---
data: "posAm1 91155"
---


 *
 */
#endif // WORKFLOW_MOB_PLATFORM_H

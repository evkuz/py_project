#ifndef ROS_MOB_PLATFORM_DESCRIPTION_H
#define ROS_MOB_PLATFORM_DESCRIPTION_H
/*
 * mobPlatform package description
 * Node list :
 * 
 * Используем ноду serial_node.py из пакета rosserial_python
 * 
 * rosrun [package_name] [node_name]
 * 
 * rosrun rosserial_python serial_node.py /dev/ttyACM0
 * Но Узел serial_node.py принадлежит библиотеке rosserial_arduino/ros_lib, а не пакету rosserial_python...
 * Сие вопрос понимания...
 * Разбираемся
 * ...
 * 
 * Это узел для обмена данными с последовательным портом.
 * 
 * Узел выполняет следующий обмен данными через ROS (создает следующие топики) :
 * - Принимает (подписан на) сообщения из топика "mobplatform" (приём команд "снаружи" в сом-порт)
 *   subscriber on mobplatform [std_msgs/String]
 *   
 * - постит сообщения в топик  "encoders" (выдача данных энкодеров из сом-порта "наружу")
 *   publisher on encoders [std_msgs/String]
 *   
 * Соответственно, для запуска двигателей мобильной платформы отправляем сообщение ("start") в топик mobplatform.
 * Узел считывает данные из этого топика
 * 
 * 
 * Узел serial_node.py принадлежит библиотеке rosserial_arduino/ros_lib
 * 
 *<launch>
  <node pkg="rosserial_python" type="serial_node.py" name="serial_node">
    <param name="port" value="/dev/ttyACM1"/>
    <param name="baud" value="115200"/>
  </node>
</launch>
 *
 *
 *
 *################################### PID #########################
 * Разница в отсчетах энкодеров за 1 оборот колеса лежит в диапазоне [15-25]
 * Соответственно, эта разница  - есть Target при вычислении pid.
 * Т.е. если разница с энкодеров больше таргета, то включаем ПИД.
 * Вернее ПИД включен все время, но при значениях разницы, больще чем таргет ПИД должен давать ненулевую уставку/добавку к скорости.
 * diff - фактическая разница в энкодерах.
 * 1. Определяем, кто больше "накрутил" - М1 или М2, соответственно, увеличиваем скорость на "отставшем" колесе.
 * 2. Обычно, отставшее - М1
 * 3. Вычисляем, насколько в единицах "оборот колеса" произошло отставание за 1 оборот (или за время таймера).
 *    backlog = (diff/m1A_k) // Получили число оборотов 
 * 4. 5 оборотов колесо совершает за ms миллисекунд., значит 1 оборот за ms/5, соответственно таймер надо вызывать примерно после каждого оборота.
 * 5. Итак, имеем оставание колеса на backlog оборотов, соответственно, надо увеличить скорость на величину backlog т.е.
 *    newSpeed = m1Speed + m1Speed*backlog.
 *    backlog - P-коэфиициент ПИДа
 *
 *
 *
 *
  */
#endif // WORKFLOW_MOB_PLATFORM_H

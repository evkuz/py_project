# $USER_HOME$: stands for your home directory.
# $PROJECT_DIR$: stands for the directory where your project is stored
#
#
#
#
#
Матрицы весовых коэффициентов связей wih (между входным и скрытым
слоями) и who (между скрытым и выходным слоями).
Весовые коэффициенты связей между узлом i и узлом j следующего слоя
обозначены как w_i_j:
wll w21
wl2 w22 и т.д.


# коэффициент обучения
        self.lr = learningrate
        
        # преобразовать список входных значений
# в двухмерный массив
inputs = numpy.array(inputs_list, ndmin=2).T
# рассчитать входящие сигналы для скрытого слоя
hidden_inputs = numpy.dot(self.wih, inputs)
# рассчитать исходящие сигналы для скрытого слоя
hidden_outputs = self.activation_function(hidden_inputs)
# рассчитать входящие сигналы для выходного слоя
final_inputs = numpy.dot(self.who, hidden__outputs)
# рассчитать исходящие сигналы для выходного слоя
final_outputs = self.activation_function(final_inputs)
return final_outputs


тре­нировка включает две фазы: первая — это расчет выходного сигнала,
что и делает функция q u e r y (), а вторая — обратное распространение ошибок,
информирующее нас о том, каковы должны быть поправки к весовым коэффициентам.

для этого нам нужно
преобразовать список чисел, разделенных запятыми, в подходящий
массив. Это можно сделать в соответствии со следующей процедурой:
• разбить длинную текстовую строку значений, разделенных за­
пятыми, на отдельные значения, используя символ запятой
в качестве разделителя;
проигнорировать первое значение, являющееся маркером, из­
влечь оставшиеся 28*28=784 значения и преобразовать их
в массив, состоящий из 28 строк и 28 столбцов;
• отобразить массив!

